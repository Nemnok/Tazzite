<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MAPA DE PIENSAS INTERACTIVAS</title>
  <style>
    /* üé® Fondo din√°mico */
    #bg {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      z-index: -1;
      display: block;
    }

    body {
      margin: 0;
      font-family: "Segoe UI", Arial, sans-serif;
      color: white;
      text-align: center;
      overflow: hidden;
    }

    h1 {
      margin-top: 1.5rem;
      font-size: 2.2rem;
      text-shadow: 0 0 15px rgba(255,255,255,0.3);
    }

    .nav-btn {
      position: fixed;
      top: 50%;
      transform: translateY(-50%);
      background-color: #7c0b19;
      color: #fff;
      border: none;
      border-radius: 12px;
      padding: 1rem 1.6rem;
      font-size: 1.05rem;
      cursor: pointer;
      box-shadow: 0 6px 18px rgba(0,0,0,0.4);
      transition: transform 0.2s, background 0.3s;
      z-index: 10;
    }
    .nav-btn:hover {
      background-color: #9b1c31;
      transform: translateY(-50%) scale(1.05);
    }
    .nav-left { left: 40px; }
    .nav-right { right: 40px; }

    #tooltip {
      position: absolute;
      padding: 6px 10px;
      border-radius: 8px;
      background: rgba(255,255,255,0.1);
      color: #fff;
      pointer-events: none;
      display: none;
      backdrop-filter: blur(4px);
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <canvas id="bg"></canvas>
  <h1>MAPA DE PIENSAS INTERACTIVAS</h1>

  <!-- Botones de navegaci√≥n -->
  <button class="nav-btn nav-left" onclick="window.location.href='index.html#ra0'">‚¨Ö Mapa General</button>
  <button class="nav-btn nav-right" onclick="window.location.href='index.html#indice'">√çndice ‚û°</button>

  <canvas id="galaxia"></canvas>
  <div id="tooltip"></div>

  <script>
    /* ===== GALAXIA ESTABLE Y CLICABLE ===== */
    const canvas = document.getElementById("galaxia");
    const ctx = canvas.getContext("2d");
    let w, h, cx, cy;
    function resize() {
      w = canvas.width = window.innerWidth;
      h = canvas.height = window.innerHeight;
      cx = w / 2;
      cy = h / 2;
    }
    window.addEventListener("resize", resize);
    resize();

    const tooltip = document.getElementById("tooltip");
    const RAs = [
      { id: "RA0", label: "MAPA", link: "index.html#ra0" },
      { id: "RA1", label: "RA1", link: "index.html#ra1" },
      { id: "RA2", label: "RA2", link: "index.html#ra2" },
      { id: "RA3", label: "RA3", link: "index.html#ra3" },
      { id: "RA4", label: "RA4", link: "index.html#ra4" },
      { id: "RA5", label: "RA5", link: "index.html#ra5" }
    ];

    const nodes = [];
    const a = 60, b = 75, step = Math.PI / 3, baseAngle = Math.random() * Math.PI * 2;
    const maxR = Math.min(window.innerWidth, window.innerHeight) / 2 - 150;

    RAs.forEach((ra, i) => {
      const theta = baseAngle + i * step;
      let r = a + b * i;
      if (r > maxR) r = maxR - i * 20;
      nodes.push({
        id: ra.id,
        label: ra.label,
        link: ra.link,
        angle: theta,
        r,
        size: i === 0 ? 22 : 15,
        color: i === 0 ? "#fff0e0" : "#ff5b6e",
        extras: []
      });
    });

    nodes.slice(1).forEach((n) => {
      const distBase = n.size * 2.4;
      for (let j = 0; j < 5; j++) {
        const dist = distBase + j * (n.size * 1.2);
        n.extras.push({
          label: "Extra " + (j + 1),
          dist,
          size: 4 + Math.random() * 1,
          angle: (Math.PI * 2 / 5) * j,
          speed: (0.001 + Math.random() * 0.0003) / 10,
          color: "#ffd6e6"
        });
      }
    });

    function draw(ts) {
      ctx.clearRect(0, 0, w, h);
      const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(w, h));
      grad.addColorStop(0, "rgba(40,0,0,0.6)");
      grad.addColorStop(1, "rgba(0,0,0,0.9)");
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, w, h);

      const coreGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, 100);
      coreGrad.addColorStop(0, "rgba(255,220,180,0.8)");
      coreGrad.addColorStop(1, "transparent");
      ctx.fillStyle = coreGrad;
      ctx.beginPath();
      ctx.arc(cx, cy, 100, 0, Math.PI * 2);
      ctx.fill();

      nodes.slice(1).forEach((n) => {
        const t = ts * 0.00025;
        const theta = n.angle + t;
        const x = cx + n.r * Math.cos(theta);
        const y = cy + n.r * Math.sin(theta);
        n.x = x; n.y = y;

        ctx.beginPath();
        ctx.strokeStyle = "rgba(255,255,255,0.07)";
        ctx.arc(cx, cy, n.r, 0, Math.PI * 2);
        ctx.stroke();

        const g = ctx.createRadialGradient(x, y, 0, x, y, n.size * 2);
        g.addColorStop(0, n.color);
        g.addColorStop(1, "transparent");
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(x, y, n.size, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "#fff";
        ctx.font = "bold 14px Segoe UI";
        ctx.textAlign = "center";
        ctx.fillText(n.label, x, y - n.size - 8);

        n.extras.forEach((e) => {
          const angle = e.angle + ts * e.speed * 2;
          const sx = x + e.dist * Math.cos(angle);
          const sy = y + e.dist * Math.sin(angle);
          e.x = sx; e.y = sy;
          e.parent = n;

          ctx.beginPath();
          ctx.strokeStyle = "rgba(255,255,255,0.05)";
          ctx.arc(x, y, e.dist, 0, Math.PI * 2);
          ctx.stroke();

          ctx.beginPath();
          ctx.fillStyle = e.color;
          ctx.arc(sx, sy, e.size, 0, Math.PI * 2);
          ctx.fill();
        });
      });
      requestAnimationFrame(draw);
    }
    requestAnimationFrame(draw);

    /* ===== CLIC ===== */
    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      for (const n of nodes.slice(1)) {
        if (Math.hypot(mx - n.x, my - n.y) < n.size + 4) {
          window.location.href = n.link;
          return;
        }
        for (const eNode of n.extras) {
          if (Math.hypot(mx - eNode.x, my - eNode.y) < eNode.size + 3) {
            window.location.href = n.link;
            return;
          }
        }
      }
    });

    /* ===== Tooltip ===== */
    canvas.addEventListener("mousemove", (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      let found = false;

      nodes.slice(1).forEach((n) => {
        if (Math.hypot(mx - n.x, my - n.y) < n.size + 4) {
          tooltip.style.display = "block";
          tooltip.textContent = n.label;
          tooltip.style.left = mx + 12 + "px";
          tooltip.style.top = my + 12 + "px";
          found = true;
        }
        n.extras.forEach((eNode) => {
          if (Math.hypot(mx - eNode.x, my - eNode.y) < eNode.size + 3) {
            tooltip.style.display = "block";
            tooltip.textContent = eNode.label + " (" + n.label + ")";
            tooltip.style.left = mx + 12 + "px";
            tooltip.style.top = my + 12 + "px";
            found = true;
          }
        });
      });
      if (!found) tooltip.style.display = "none";
    });

    /* ===== Fondo animado ===== */
    const bg = document.getElementById("bg");
    const bgCtx = bg.getContext("2d",{alpha:true});
    let bw,bh,dpr;
    function bgResize(){
      dpr=Math.max(1,Math.min(window.devicePixelRatio||1,2));
      bw=bg.width=Math.floor(window.innerWidth*dpr);
      bh=bg.height=Math.floor(window.innerHeight*dpr);
      bg.style.width=window.innerWidth+'px';
      bg.style.height=window.innerHeight+'px';
    }
    window.addEventListener('resize',bgResize,{passive:true});
    bgResize();

    const BLOBS=7;
    const blobs=Array.from({length:BLOBS}).map(()=>({
      x0:Math.random()*bw,y0:Math.random()*bh,
      r:Math.min(bw,bh)*(0.18+Math.random()*0.22),
      spx:0.0003+Math.random()*0.0007,
      spy:0.0003+Math.random()*0.0007,
      a:0.18+Math.random()*0.15,
      hue:350+Math.random()*20,
      phase:Math.random()*Math.PI*2
    }));

    function bgGradient(t){
      const g=bgCtx.createLinearGradient(0,0,bw,bh);
      const sh=Math.sin(t*0.0002)*10;
      g.addColorStop(0,`hsl(${350+sh},68%,32%)`);
      g.addColorStop(1,`hsl(${3+sh},70%,48%)`);
      return g;
    }

    function bgTick(ts){
      requestAnimationFrame(bgTick);
      bgCtx.globalCompositeOperation='source-over';
      bgCtx.fillStyle=bgGradient(ts);
      bgCtx.fillRect(0,0,bw,bh);
      bgCtx.fillStyle='rgba(0,0,0,0.08)';
      bgCtx.fillRect(0,0,bw,bh);
      bgCtx.globalCompositeOperation='lighter';
      blobs.forEach((b,i)=>{
        const t=ts+i*1000;
        const x=(b.x0+Math.sin(t*b.spx+b.phase)*(bw*0.25))%bw;
        const y=(b.y0+Math.cos(t*b.spy+b.phase)*(bh*0.25))%bh;
        const g=bgCtx.createRadialGradient(x,y,0,x,y,b.r);
        const hueShift=Math.sin(t*0.0003+b.phase)*15;
        const c=`hsla(${b.hue+hueShift},70%,60%,${b.a})`;
        g.addColorStop(0,c);g.addColorStop(1,'hsla(0,0%,0%,0)');
        bgCtx.fillStyle=g;bgCtx.beginPath();bgCtx.arc(x,y,b.r,0,Math.PI*2);bgCtx.fill();
      });
      bgCtx.globalCompositeOperation='multiply';
      const v=bgCtx.createRadialGradient(bw*0.5,bh*0.5,Math.min(bw,bh)*0.3,bw*0.5,bh*0.5,Math.max(bw,bh)*0.7);
      v.addColorStop(0,'rgba(0,0,0,0)');
      v.addColorStop(1,'rgba(0,0,0,0.22)');
      bgCtx.fillStyle=v;bgCtx.fillRect(0,0,bw,bh);
      bgCtx.globalCompositeOperation='source-over';
    }
    requestAnimationFrame(bgTick);
  </script>
</body>
</html>
